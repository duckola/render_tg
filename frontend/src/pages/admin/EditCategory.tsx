import { useState, useMemo, useEffect } from 'react';
import { useParams, useNavigate, useLocation } from 'react-router-dom';
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { categoryService } from '../../services/categoryService';
import { menuService } from '../../services/menuService';
import { Category } from '../../types';
import '../../styles/admin.css';
import './EditCategory.css';
import toast from 'react-hot-toast';

export const EditCategory = () => {
  const { id } = useParams<{ id: string }>();
  const location = useLocation();
  const navigate = useNavigate();
  const queryClient = useQueryClient();
  // Check if we're on the "new" route - the route doesn't have :id param, so we check the pathname
  const isNew = !id || location.pathname.endsWith('/new');
  
  // Debug: Log the route parameters
  console.log('EditCategory - pathname:', location.pathname, 'id from params:', id, 'isNew:', isNew);

  const [categoryName, setCategoryName] = useState('');
  const [assignedItemIds, setAssignedItemIds] = useState<Set<number>>(new Set());
  const [searchQuery, setSearchQuery] = useState('');

  // Fetch category if editing
  const { data: category } = useQuery({
    queryKey: ['category', id],
    queryFn: () => categoryService.getOne(Number(id!)),
    enabled: !isNew && !!id,
  });

  // Fetch all menu items
  const { data: allMenuItems } = useQuery({
    queryKey: ['menuItems'],
    queryFn: menuService.getAllMenuItems,
  });

  // Update form when category loads
  useEffect(() => {
    if (category) {
      setCategoryName(category.categoryName);
      // Get assigned items from menu items that have this categoryId
      // Filter out invalid itemIds (NaN, undefined, null, or <= 0)
      if (allMenuItems) {
        const assigned = allMenuItems
          .filter((item) => item.categoryId === category.categoryId)
          .map((item) => item.itemId)
          .filter((itemId): itemId is number => 
            itemId !== undefined && 
            itemId !== null && 
            !Number.isNaN(itemId) && 
            Number.isFinite(itemId) && 
            itemId > 0
          );
        setAssignedItemIds(new Set(assigned));
      }
    }
  }, [category, allMenuItems]);

  // Update assigned items when menu items load
  useEffect(() => {
    if (!isNew && category && allMenuItems) {
      // Filter out invalid itemIds (NaN, undefined, null, or <= 0)
      const assigned = allMenuItems
        .filter((item) => item.categoryId === category.categoryId)
        .map((item) => item.itemId)
        .filter((itemId): itemId is number => 
          itemId !== undefined && 
          itemId !== null && 
          !Number.isNaN(itemId) && 
          Number.isFinite(itemId) && 
          itemId > 0
        );
      setAssignedItemIds(new Set(assigned));
    }
  }, [isNew, category, allMenuItems]);

  const createMutation = useMutation({
    mutationFn: (payload: Partial<Category>) => {
      // Ensure payload only contains valid data
      const cleanPayload: Partial<Category> = {
        categoryName: payload.categoryName?.trim() || '',
      };
      return categoryService.create(cleanPayload);
    },
    onSuccess: async (newCategory) => {
      console.log('Category created successfully, response:', newCategory);
      toast.success('Category created successfully');
      
      // Validate that we received a valid category with a valid categoryId
      // The backend auto-generates categoryId via AUTO_INCREMENT, so it should always be present
      if (!newCategory) {
        console.error('No category in response');
        queryClient.invalidateQueries({ queryKey: ['categories'] });
        navigate('/admin/categories');
        return;
      }
      
      // The categoryId should be auto-generated by the database (AUTO_INCREMENT)
      // and returned in the response
      const categoryId = newCategory.categoryId;
      console.log('Extracted categoryId from response:', categoryId, 'type:', typeof categoryId);
      
      if (!categoryId) {
        console.error('categoryId is missing from response:', newCategory);
        queryClient.invalidateQueries({ queryKey: ['categories'] });
        navigate('/admin/categories');
        return;
      }
      
      // Ensure categoryId is a valid number (it should be a number from the API)
      const numericCategoryId = typeof categoryId === 'number' ? categoryId : Number(categoryId);
      if (Number.isNaN(numericCategoryId) || !Number.isFinite(numericCategoryId) || numericCategoryId <= 0) {
        console.error('Invalid categoryId from API (should be auto-generated positive number):', categoryId, 'converted:', numericCategoryId);
        queryClient.invalidateQueries({ queryKey: ['categories'] });
        navigate('/admin/categories');
        return;
      }
      
      console.log('Valid categoryId received:', numericCategoryId, 'assignedItemIds:', Array.from(assignedItemIds || []));
      
      // If no items are assigned, skip menu item updates
      if (!assignedItemIds || assignedItemIds.size === 0) {
        console.log('No items assigned to new category, skipping menu item updates');
        queryClient.invalidateQueries({ queryKey: ['categories'] });
        queryClient.invalidateQueries({ queryKey: ['menuItems'] });
        navigate('/admin/categories');
        return;
      }
      
      // Update menu items to assign them to the new category using the auto-generated categoryId
      await updateMenuItemsCategory(numericCategoryId);
    },
    onError: (e: any) => {
      console.error('Category creation error:', e);
      const errorMessage = e.response?.data?.message || e.message || 'Failed to create category';
      toast.error(errorMessage);
    },
  });

  const updateMutation = useMutation({
    mutationFn: ({ id, payload }: { id: number; payload: Partial<Category> }) => {
      // Validate id before making API call
      if (!id || Number.isNaN(id) || !Number.isFinite(id) || id <= 0) {
        throw new Error(`Invalid category id: ${id}`);
      }
      return categoryService.update(id, payload);
    },
    onSuccess: (data, variables) => {
      toast.success('Category updated');
      // Validate id before updating menu items
      const categoryId = Number(variables.id);
      if (!Number.isNaN(categoryId) && Number.isFinite(categoryId) && categoryId > 0) {
        updateMenuItemsCategory(categoryId);
      } else {
        console.error('Invalid category id after update:', variables.id);
        queryClient.invalidateQueries({ queryKey: ['categories'] });
        navigate('/admin/categories');
      }
    },
    onError: (e: any) => toast.error(e.response?.data?.message || 'Failed to update category'),
  });

  const updateMenuItemsMutation = useMutation({
    mutationFn: async ({ itemId, categoryId }: { itemId: number; categoryId: number | null }) => {
      // Validate itemId first - must be a valid positive number
      if (!itemId || Number.isNaN(itemId) || !Number.isFinite(itemId) || itemId <= 0) {
        console.error('Invalid itemId:', itemId);
        throw new Error(`Invalid itemId: ${itemId}`);
      }
      
      const item = allMenuItems?.find((m) => m.itemId === itemId);
      if (!item) {
        console.error('Menu item not found for itemId:', itemId);
        throw new Error(`Menu item not found for itemId: ${itemId}`);
      }
      
      // Validate and clean categoryId - ensure it's a valid number or null
      // Never send "NaN" as string or NaN as number
      // IMPORTANT: We must send null (not undefined) because JSON.stringify omits undefined,
      // and the backend DTO expects null to remove the category
      // Also ensure item.categoryId is not used if it's invalid
      let validCategoryId: number | null = null;
      if (categoryId !== null && categoryId !== undefined) {
        // Handle different types - categoryId could be number, string, or other
        const categoryIdValue = categoryId as number | string | unknown;
        
        if (typeof categoryIdValue === 'string') {
          // Handle string "NaN" case
          const trimmed = categoryIdValue.trim();
          if (trimmed === 'NaN' || trimmed === '' || trimmed.toLowerCase() === 'null') {
            validCategoryId = null;
          } else {
            const numCategoryId = Number(trimmed);
            if (!Number.isNaN(numCategoryId) && Number.isFinite(numCategoryId) && numCategoryId > 0) {
              validCategoryId = numCategoryId;
            }
          }
        } else if (typeof categoryIdValue === 'number') {
          // Validate number - reject NaN, Infinity, and non-positive numbers
          if (!Number.isNaN(categoryIdValue) && Number.isFinite(categoryIdValue) && categoryIdValue > 0) {
            validCategoryId = categoryIdValue;
          }
        }
      }
      // If categoryId is null, undefined, or invalid, validCategoryId stays null
      
      // Build payload - explicitly set categoryId to number or null (never undefined or NaN)
      // Backend DTO expects null to remove category, number to set category
      // Note: Using Record type to allow null for categoryId (MenuItem type expects number | undefined)
      // Ensure all values are valid - don't trust item data if it contains invalid values
      const payload: Record<string, any> = {
        name: item.name || '',
        description: item.description || '',
        price: item.price && !Number.isNaN(Number(item.price)) ? item.price : 0,
        imageUrl: item.imageUrl || '',
        isAvailable: item.isAvailable ?? true,
        categoryId: validCategoryId, // number | null - backend expects null, not undefined
      };
      
      // Final validation - ensure categoryId is never NaN or invalid
      if (payload.categoryId !== null && (Number.isNaN(payload.categoryId) || payload.categoryId <= 0)) {
        payload.categoryId = null;
      }
      
      return menuService.updateMenuItem(itemId, payload);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['menuItems'] });
      queryClient.invalidateQueries({ queryKey: ['categories'] });
    },
    onError: (e: any) => {
      console.error('Failed to update menu item category:', e);
      console.error('Payload that failed:', e.config?.data);
      toast.error(e.response?.data?.message || 'Failed to update menu item');
    },
  });

  const updateMenuItemsCategory = async (categoryId: number) => {
    // Validate categoryId first
    if (!categoryId || Number.isNaN(categoryId) || !Number.isFinite(categoryId) || categoryId <= 0) {
      console.error('Invalid categoryId:', categoryId);
      queryClient.invalidateQueries({ queryKey: ['categories'] });
      navigate('/admin/categories');
      return;
    }

    // If no menu items exist or no items are assigned, just navigate away
    if (!allMenuItems || assignedItemIds.size === 0) {
      queryClient.invalidateQueries({ queryKey: ['categories'] });
      queryClient.invalidateQueries({ queryKey: ['menuItems'] });
      navigate('/admin/categories');
      return;
    }

    try {
      // Filter out invalid itemIds before making API calls
      const validItemIds = Array.from(assignedItemIds).filter(
        (itemId) => {
          const isValid = itemId !== undefined && 
                         itemId !== null && 
                         !Number.isNaN(itemId) && 
                         Number.isFinite(itemId) && 
                         itemId > 0;
          if (!isValid) {
            console.warn('Filtered out invalid itemId:', itemId, typeof itemId);
          }
          return isValid;
        }
      );

      console.log('Updating menu items with categoryId:', categoryId, 'for itemIds:', validItemIds);

      if (validItemIds.length === 0) {
        console.log('No valid itemIds to update, skipping menu item updates');
        queryClient.invalidateQueries({ queryKey: ['categories'] });
        queryClient.invalidateQueries({ queryKey: ['menuItems'] });
        navigate('/admin/categories');
        return;
      }

      // Update all assigned items to have this categoryId
      const updatePromises = validItemIds.map((itemId) => {
        // Double-check itemId is valid before making the call
        if (!itemId || Number.isNaN(itemId) || !Number.isFinite(itemId) || itemId <= 0) {
          console.error('Skipping invalid itemId in update promise:', itemId);
          return Promise.resolve(null);
        }
        return updateMenuItemsMutation.mutateAsync({ itemId, categoryId }).catch((error) => {
          console.error(`Failed to update menu item ${itemId}:`, error);
          // Continue with other updates even if one fails
          return null;
        });
      });

      // Update all previously assigned items (that are no longer assigned) to remove categoryId
      // Only do this when editing (not creating new category)
      const previouslyAssigned = !isNew
        ? allMenuItems
            .filter((item) => item.categoryId === categoryId && !assignedItemIds.has(item.itemId))
            .map((item) => item.itemId)
            .filter((itemId) => itemId && !Number.isNaN(itemId) && Number.isFinite(itemId) && itemId > 0)
        : [];

      const removePromises = previouslyAssigned.map((itemId) =>
        updateMenuItemsMutation.mutateAsync({ itemId, categoryId: null }).catch((error) => {
          console.error(`Failed to remove category from menu item ${itemId}:`, error);
          // Continue with other updates even if one fails
          return null;
        })
      );

      // Wait for all updates to complete (some may fail, but we continue)
      await Promise.all([...updatePromises, ...removePromises]);
    } catch (error) {
      console.error('Error updating menu items:', error);
      // Continue to navigation even if updates fail
    }
    
    queryClient.invalidateQueries({ queryKey: ['categories'] });
    queryClient.invalidateQueries({ queryKey: ['menuItems'] });
    navigate('/admin/categories');
  };

  const handleSubmit = () => {
    const trimmedName = categoryName.trim();
    if (!trimmedName) {
      toast.error('Category name is required');
      return;
    }

    if (isNew) {
      console.log('Creating category with name:', trimmedName);
      createMutation.mutate({ categoryName: trimmedName });
    } else {
      // Validate id before using it
      if (!id || Number.isNaN(Number(id)) || Number(id) <= 0) {
        console.error('Invalid category id for update:', id);
        toast.error('Invalid category ID');
        return;
      }
      console.log('Updating category:', id, 'with name:', trimmedName);
      updateMutation.mutate({ id: Number(id), payload: { categoryName: trimmedName } });
    }
  };

  const handleAddItem = (itemId: number) => {
    // Validate itemId before adding
    if (itemId && !Number.isNaN(itemId) && Number.isFinite(itemId) && itemId > 0) {
      setAssignedItemIds((prev) => new Set([...prev, itemId]));
    } else {
      console.error('Invalid itemId when adding:', itemId);
    }
  };

  const handleRemoveItem = (itemId: number) => {
    // Validate itemId before removing
    if (itemId && !Number.isNaN(itemId) && Number.isFinite(itemId)) {
      setAssignedItemIds((prev) => {
        const newSet = new Set(prev);
        newSet.delete(itemId);
        return newSet;
      });
    }
  };

  const assignedItems = useMemo(() => {
    if (!allMenuItems) return [];
    return allMenuItems.filter((item) => assignedItemIds.has(item.itemId));
  }, [allMenuItems, assignedItemIds]);

  const availableItems = useMemo(() => {
    if (!allMenuItems) return [];
    return allMenuItems.filter(
      (item) => !assignedItemIds.has(item.itemId) && item.name.toLowerCase().includes(searchQuery.toLowerCase())
    );
  }, [allMenuItems, assignedItemIds, searchQuery]);

  const getInitials = (name: string) => {
    return name
      .split(' ')
      .map((word) => word[0])
      .join('')
      .toUpperCase()
      .slice(0, 2);
  };

  const getIconColor = (name: string) => {
    const hash = name.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
    const colors = ['#F4C430', '#FF9800', '#E91E63'];
    return colors[hash % colors.length];
  };

  return (
    <div className="edit-category-page">
      <div className="admin-card edit-category-card">
        <div className="form-header">
          <h1 className="form-title">
            {isNew ? 'Add Category' : `Edit Category: ${category?.categoryName || ''}`}
          </h1>
        </div>

        <form
          onSubmit={(e) => {
            e.preventDefault();
            handleSubmit();
          }}
        >
          {/* Category Name Input */}
          <div className="form-group">
            <label htmlFor="category-name" className="form-label">
              Category Name
            </label>
            <input
              id="category-name"
              type="text"
              className="form-input"
              value={categoryName}
              onChange={(e) => setCategoryName(e.target.value)}
              placeholder="e.g. Rice & Noodles"
            />
          </div>

          {/* Two Column Layout */}
          <div className="manage-items-grid">
            {/* Assigned Items Column */}
            <div className="item-column">
              <div className="column-header">
                <span>Assigned Menu Items ({assignedItems.length})</span>
              </div>
              <ul className="item-list">
                {assignedItems.length > 0 ? (
                  assignedItems.map((item) => (
                    <li key={item.itemId} className="item-row">
                      <div className="item-info">
                        <div
                          className="item-initial"
                          style={{ background: getIconColor(item.name) }}
                        >
                          {getInitials(item.name)}
                        </div>
                        <span className="item-name">{item.name}</span>
                      </div>
                      <button
                        type="button"
                        className="btn-action btn-remove"
                        onClick={() => handleRemoveItem(item.itemId)}
                      >
                        <i className="fa-solid fa-minus"></i> Remove
                      </button>
                    </li>
                  ))
                ) : (
                  <li className="item-row empty">No items assigned</li>
                )}
              </ul>
            </div>

            {/* Available Items Column */}
            <div className="item-column">
              <div className="column-header">
                <span>Assign More Items</span>
              </div>
              <div className="search-box">
                <i className="fa-solid fa-search"></i>
                <input
                  type="text"
                  className="search-input"
                  placeholder="Search Menu Items..."
                  value={searchQuery}
                  onChange={(e) => setSearchQuery(e.target.value)}
                />
              </div>
              <ul className="item-list">
                {availableItems.length > 0 ? (
                  availableItems.map((item) => (
                    <li key={item.itemId} className="item-row">
                      <div className="item-info">
                        <div
                          className="item-initial"
                          style={{ background: getIconColor(item.name) }}
                        >
                          {getInitials(item.name)}
                        </div>
                        <span className="item-name">{item.name}</span>
                      </div>
                      <button
                        type="button"
                        className="btn-action btn-add"
                        onClick={() => handleAddItem(item.itemId)}
                      >
                        <i className="fa-solid fa-plus"></i> Add
                      </button>
                    </li>
                  ))
                ) : (
                  <li className="item-row empty">No items available</li>
                )}
              </ul>
            </div>
          </div>

          {/* Action Buttons */}
          <div className="btn-row">
            <button type="button" className="btn btn-cancel" onClick={() => navigate('/admin/categories')}>
              Cancel
            </button>
            <button
              type="submit"
              className="btn btn-save"
              disabled={createMutation.isPending || updateMutation.isPending}
            >
              {createMutation.isPending || updateMutation.isPending ? 'Saving...' : 'Save Changes'}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

